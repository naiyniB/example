<!doctype html>
<html>
  <head>
    <style>
      body {
        margin: 0;
        background: #050505;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        overflow: hidden;
      }
      canvas {
        border-radius: 20px;
        cursor: pointer;
      }
      .hint {
        position: fixed;
        bottom: 20px;
        color: #666;
        font-family: sans-serif;
      }
    </style>
  </head>
  <body>
    <canvas id="glassCanvas"></canvas>
    <div class="hint">移动鼠标感受边缘折射高光</div>

    <script>
      const canvas = document.getElementById("glassCanvas");
      const ctx = canvas.getContext("2d");

      let width = 600;
      let height = 400;
      canvas.width = width;
      canvas.height = height;

      let mouse = { x: width / 2, y: height / 2 };

      // 1. 创建背景（模拟 macOS 的流体感）
      function drawBackground(t) {
        const grad = ctx.createRadialGradient(
          width / 2 + Math.sin(t / 1000) * 100,
          height / 2,
          0,
          width / 2,
          height / 2,
          width,
        );
        grad.addColorStop(0, "#4facfe");
        grad.addColorStop(1, "#00f2fe");
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, width, height);

        // 增加一些漂浮的气泡
        for (let i = 0; i < 3; i++) {
          ctx.beginPath();
          ctx.fillStyle = "rgba(255,255,255,0.1)";
          ctx.arc(
            width / 2 + Math.cos((t + i * 1000) / 500) * 200,
            height / 2 + Math.sin((t + i * 1000) / 700) * 100,
            50,
            0,
            Math.PI * 2,
          );
          ctx.fill();
        }
      }

      function drawLiquidGlass(t) {
        const glassW = 340;
        const glassH = 200;
        const x = (width - glassW) / 2;
        const y = (height - glassH) / 2;

        ctx.save();

        // --- 第一层：阴影 ---
        ctx.shadowColor = "rgba(0,0,0,0.3)";
        ctx.shadowBlur = 30;
        ctx.shadowOffsetY = 15;

        // --- 第二层：主体模糊 ---
        // Canvas 里的液态模糊通常通过叠加多次实现
        ctx.beginPath();
        ctx.roundRect(x, y, glassW, glassH, 30);
        ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
        ctx.fill();

        // 使用滤镜实现背景模糊 (部分浏览器需要前缀)
        ctx.filter = "blur(20px) saturate(180%)";
        // 这里是一个技巧：重新绘制局部背景并裁切
        ctx.clip();
        drawBackground(t);
        ctx.filter = "none";
        ctx.restore();

        // --- 第三层：边缘折射高光 (核心) ---
        // 我们根据鼠标位置计算受光面
        const angle = Math.atan2(mouse.y - height / 2, mouse.x - width / 2);

        ctx.save();
        ctx.translate(width / 2, height / 2);

        // 顶层边缘亮线
        ctx.beginPath();
        ctx.roundRect(-glassW / 2, -glassH / 2, glassW, glassH, 30);
        const highlightGrad = ctx.createLinearGradient(
          Math.cos(angle) * 100,
          Math.sin(angle) * 100,
          -Math.cos(angle) * 100,
          -Math.sin(angle) * 100,
        );
        highlightGrad.addColorStop(0, "rgba(255,255,255,0.6)"); // 受光面亮
        highlightGrad.addColorStop(0.5, "rgba(255,255,255,0.05)");
        highlightGrad.addColorStop(1, "rgba(255,255,255,0.2)"); // 背光面微亮（折射）

        ctx.strokeStyle = highlightGrad;
        ctx.lineWidth = 2;
        ctx.stroke();

        // 内部极细的高光路径
        ctx.beginPath();
        ctx.roundRect(
          -glassW / 2 + 3,
          -glassH / 2 + 3,
          glassW - 6,
          glassH - 6,
          27,
        );
        ctx.strokeStyle = "rgba(255,255,255,0.1)";
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.restore();

        // --- 第四层：表面光泽 ---
        const shine = ctx.createRadialGradient(
          mouse.x,
          mouse.y,
          0,
          mouse.x,
          mouse.y,
          400,
        );
        shine.addColorStop(0, "rgba(255,255,255,0.08)");
        shine.addColorStop(1, "transparent");
        ctx.fillStyle = shine;
        ctx.roundRect(x, y, glassW, glassH, 30);
        ctx.fill();
      }

      function render(t) {
        ctx.clearRect(0, 0, width, height);
        drawBackground(t);
        drawLiquidGlass(t);
        requestAnimationFrame(render);
      }

      canvas.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        mouse.x = e.clientX - rect.left;
        mouse.y = e.clientY - rect.top;
      });

      render(0);
    </script>
  </body>
</html>
